<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://bnm3k.github.io//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bnm3k.github.io//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bnm3k.github.io//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://bnm3k.github.io//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://bnm3k.github.io//apple-touch-icon.png><meta name=description content><title>Graph Query Interfaces: A Comparison Between SQL and Cypher | bnm 3000
</title><link rel=canonical href=https://bnm3k.github.io/blog/sql-cypher-flights/><meta property="og:url" content="https://bnm3k.github.io/blog/sql-cypher-flights/"><meta property="og:site_name" content="bnm 3000"><meta property="og:title" content="Graph Query Interfaces: A Comparison Between SQL and Cypher"><meta property="og:description" content="Featuring DuckDB & KuzuDB"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-17T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-17T00:00:00+00:00"><meta property="article:tag" content="DuckDB"><meta property="article:tag" content="SQL"><link rel=stylesheet href=/assets/combined.min.186794b3399a702d3092949042cdc215dea303c17e71e7c0254768448de11db8.css media=all></head><body class=light><div class=content><header><div class=header><h1 class=header-title><a href=https://bnm3k.github.io/>bnm 3000</a></h1><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/notes>/notes</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/posts/>Posts</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/blog/sql-cypher-flights/>Graph Query Interfaces: A Comparison Between SQL and Cypher</a></div><div><div class=single-intro-container><h1 class=single-title>Graph Query Interfaces: A Comparison Between SQL and Cypher</h1><p class=single-summary>Featuring DuckDB & KuzuDB</p><p class=single-readtime><time datetime=2024-10-17T00:00:00+00:00>October 17, 2024</time>
&nbsp; · &nbsp;
12 min read</p></div><div class=single-content><p>Egor Rogov (author of one of my favourite book, PostgreSQL Internals) wrote this
illustrative article,
<a href=https://habr.com/en/companies/postgrespro/articles/490228/>On recursive queries</a>
that&rsquo;s worth reading for SQL aficionados. The dataset used is the
<a href=https://postgrespro.com/docs/postgrespro/12/demodb-bookings>airlines demo database</a> -
it consists of airports, flights available between these airports and other
details such as planes used and flight durations. The article concludes with a
couple of intermediate/advanced exercises that involve using SQL to solve some
variation of finding paths or routes between locations (nodes) that fulfill some
condition or constraint e.g. minimum number of airport hops or least waiting
time.</p><p>Now, I did have fun working through the exercises. However, I&rsquo;m curious if Graph
Databases could simplify modeling and solving such tasks. The aspect I&rsquo;m
focusing on is the <em>interface</em> - that is, to quote Larry Wall, for these kinds
of problems I&rsquo;m hoping Graph DBs to &ldquo;make the easy things easy and the hard
things possible&rdquo;.</p><p>I&rsquo;d also like to note, this isn&rsquo;t a proper rigorous comparison or study, I&rsquo;m
just expecting that as a novice in graph databases, I should not break much of a
sweat. If I&rsquo;m spending too much time and finding it too complicated to formulate
the equivalent graph queries, then maybe the interface aspect is oversold (if to
no one else then at least to me).</p><p>By interface I mean the &lsquo;UI/UX&rsquo; with regards to data modeling and data querying.
For modeling, I find the relational approach quite neat. In my career thus far,
I&rsquo;ve yet to come across a business case that couldn&rsquo;t be modeled relationally
and, (maybe I&rsquo;m in a bubble here), I&rsquo;ve yet to meet anyone (including myself)
complain about being limited or inconvenienced by the relational model. As for
querying, SQL isn&rsquo;t quite everyone&rsquo;s cup of tea (see
<a href=https://www.scattered-thoughts.net/writing/against-sql/>Against SQL</a> for a
decent overview of SQL&rsquo;s shortcomings). Sure, there are
<a href=https://prql-lang.org/>newer query languages</a> and
<a href=https://research.google/pubs/sql-has-problems-we-can-fix-them-pipe-syntax-in-sql/>extensions</a>
that are meant to address SQL&rsquo;s deficiency but for the time being, we&rsquo;re pretty
much stuck with it. I won&rsquo;t complain much about SQL as an interface probably
because I&rsquo;ve gotten used to it.</p><p>I&rsquo;ll be using DuckDB as the representative relational DB and KuzuDB as the
representative Graph DB. Both are
<a href=https://www.sqlite.org/serverless.html>serverless</a> plus I&rsquo;m a big fan of
DuckDB&rsquo;s SQL dialect (which is derived from Postgres&rsquo;s). Also it doesn&rsquo;t hurt
that KuzuDB integrates directly with DuckDB which means I don&rsquo;t have to do a
separate ETL/ELT.</p><p>Let&rsquo;s start with an overview of the database. Here&rsquo;s the high-level schema:</p><p><figure><div><img loading=lazy alt="schema for the flights DB" src=/assets/images/graph_db_cypher/schema_flights.png></div></figure></p><p>A flight between two airports is scheduled to start at a certain time for some
or all days of the week plus take some expected amount of time and use the
assigned aircraft. Given that it&rsquo;s periodic, it&rsquo;s assigned a unique ID
<code>flight_no</code>. The <code>flights</code> table records all flights, those that already took
place, the ones currently taking place (at the time the dataset was being
collected), any flight that was canceled and even future scheduled flights.</p><p>To simplify analysis, we&rsquo;ll focus on distinct flights (by <code>flight_no</code>)
regardless of how many times that flight appears in the <code>flights</code> table. Hence
the <code>routes</code> view which lists all the distinct flights, plus we&rsquo;ve got the
departure point, arrival point, how long the flight is expected to take, and
which days of the week the flight is offered.</p><p>The <code>routes</code> view is defined as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>create</span> <span style=font-weight:700>or</span> <span style=font-weight:700>replace</span> <span style=font-weight:700>view</span> routes <span style=font-weight:700>as</span>
</span></span><span style=display:flex><span><span style=font-weight:700>with</span> t <span style=font-weight:700>as</span> (
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        flight_no,
</span></span><span style=display:flex><span>        list_sort(list_distinct(array_agg(weekday(scheduled_departure)))) <span style=font-weight:700>as</span> days_of_week
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> flights
</span></span><span style=display:flex><span>    <span style=font-weight:700>group</span> <span style=font-weight:700>by</span> flight_no
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> <span style=font-weight:700>distinct</span> <span style=font-weight:700>on</span>(flight_no)
</span></span><span style=display:flex><span>    f.flight_no,
</span></span><span style=display:flex><span>    f.departure_airport,
</span></span><span style=display:flex><span>    d.airport_name <span style=font-weight:700>as</span> departure_airport_name,
</span></span><span style=display:flex><span>    d.city <span style=font-weight:700>as</span> departure_airport,
</span></span><span style=display:flex><span>    f.arrival_airport,
</span></span><span style=display:flex><span>    a.airport_name <span style=font-weight:700>as</span> arrival_airport_name,
</span></span><span style=display:flex><span>    a.city <span style=font-weight:700>as</span> arrival_city,
</span></span><span style=display:flex><span>    f.aircraft_code,
</span></span><span style=display:flex><span>    (f.scheduled_arrival - f.scheduled_departure) <span style=font-weight:700>as</span> duration,
</span></span><span style=display:flex><span>    t.days_of_week
</span></span><span style=display:flex><span><span style=font-weight:700>from</span> flights f
</span></span><span style=display:flex><span><span style=font-weight:700>join</span> t <span style=font-weight:700>using</span>(flight_no)
</span></span><span style=display:flex><span><span style=font-weight:700>join</span> airports d <span style=font-weight:700>on</span> f.departure_airport = d.airport_code
</span></span><span style=display:flex><span><span style=font-weight:700>join</span> airports a <span style=font-weight:700>on</span> f.arrival_airport = a.airport_code
</span></span></code></pre></div><p>And here&rsquo;s the schema for the <code>routes</code> view:</p><pre tabindex=0><code>         View &#34;bookings.routes&#34;

         Column         │     Type     
════════════════════════╪══════════════
 flight_no              │ varchar 
 departure_airport      │ varchar 
 departure_airport_name │ varchar 
 departure_city         │ varchar 
 arrival_airport        │ varchar 
 arrival_airport_name   │ varchar 
 arrival_city           │ varchar 
 aircraft_code          │ varchar 
 duration               │ interval     
 days_of_week           │ int64[]
</code></pre><p>Now, suppose we want to search for the shortest route that starts from Ust-Kut
airport (UKX) and ends at Chulman Airport in Neryungri (CNN). Here&rsquo;s how to do
it in SQL:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-style:italic>-- shortest route from UKX to CNN
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> starting_point = <span style=font-style:italic>&#39;UKX&#39;</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> destination = <span style=font-style:italic>&#39;CNN&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>with</span> <span style=font-weight:700>recursive</span> p(hops, flights, curr_airport, <span style=font-weight:700>found</span>) <span style=font-weight:700>as</span> (
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        [getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>)], <span style=font-style:italic>-- hops
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        []::varchar[], <span style=font-style:italic>-- flights taken
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>),
</span></span><span style=display:flex><span>        getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>) = <span style=font-weight:700>next</span>.airport_code <span style=font-style:italic>-- found?
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>from</span> airports <span style=font-weight:700>next</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> <span style=font-weight:700>next</span>.airport_code = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>union</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        list_append(p.hops, r.arrival_airport),
</span></span><span style=display:flex><span>        list_append(p.flights, r.flight_no),
</span></span><span style=display:flex><span>        r.arrival_airport, <span style=font-style:italic>-- curr airport
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        bool_or(r.arrival_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)) over()
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> routes r, p
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> r.departure_airport = p.curr_airport
</span></span><span style=display:flex><span>    <span style=font-weight:700>and</span> <span style=font-weight:700>not</span> r.arrival_airport = <span style=font-weight:700>any</span>(p.hops)
</span></span><span style=display:flex><span>    <span style=font-weight:700>and</span> <span style=font-weight:700>not</span> p.<span style=font-weight:700>found</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> hops, flights
</span></span><span style=display:flex><span><span style=font-weight:700>from</span> p
</span></span><span style=display:flex><span><span style=font-weight:700>where</span> p.curr_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)
</span></span></code></pre></div><p>Egor explains how the above query works and one might go about formulating it so
do check out his post if you&rsquo;re interested.</p><p>Running it we get the following result:</p><pre tabindex=0><code>┌───────────────────────────┬──────────────────────────────────┐
│           hops            │             flights              │
│         varchar[]         │            varchar[]             │
├───────────────────────────┼──────────────────────────────────┤
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0207, PG0390, PG0036] │
│ [UKX, KJA, OVB, PEE, CNN] │ [PG0022, PG0207, PG0186, PG0394] │
│ [UKX, KJA, BAX, ASF, CNN] │ [PG0022, PG0653, PG0595, PG0427] │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0206, PG0390, PG0036] │
│ [UKX, KJA, OVB, PEE, CNN] │ [PG0022, PG0206, PG0186, PG0394] │
│ [UKX, KJA, SVO, ASF, CNN] │ [PG0022, PG0548, PG0128, PG0427] │
│ [UKX, KJA, SVO, MJZ, CNN] │ [PG0022, PG0548, PG0120, PG0036] │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0207, PG0390, PG0035] │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0206, PG0390, PG0035] │
│ [UKX, KJA, SVO, MJZ, CNN] │ [PG0022, PG0548, PG0120, PG0035] │
│ [UKX, KJA, SVO, LED, CNN] │ [PG0022, PG0548, PG0470, PG0245] │
│ [UKX, KJA, SVO, LED, CNN] │ [PG0022, PG0548, PG0469, PG0245] │
│ [UKX, KJA, SVO, LED, CNN] │ [PG0022, PG0548, PG0471, PG0245] │
│ [UKX, KJA, OVS, LED, CNN] │ [PG0022, PG0689, PG0686, PG0245] │
│ [UKX, KJA, SVO, LED, CNN] │ [PG0022, PG0548, PG0472, PG0245] │
│ [UKX, KJA, SVO, LED, CNN] │ [PG0022, PG0548, PG0468, PG0245] │
│ [UKX, KJA, NUX, DME, CNN] │ [PG0022, PG0623, PG0165, PG0709] │
│ [UKX, KJA, BAX, DME, CNN] │ [PG0022, PG0653, PG0117, PG0709] │
│ [UKX, KJA, OVB, DME, CNN] │ [PG0022, PG0207, PG0223, PG0709] │
│ [UKX, KJA, OVB, DME, CNN] │ [PG0022, PG0206, PG0223, PG0709] │
│ [UKX, KJA, OVS, DME, CNN] │ [PG0022, PG0689, PG0543, PG0709] │
│ [UKX, KJA, KRO, DME, CNN] │ [PG0022, PG0673, PG0371, PG0709] │
│ [UKX, KJA, OVS, DME, CNN] │ [PG0022, PG0689, PG0544, PG0709] │
├───────────────────────────┴──────────────────────────────────┤
│ 23 rows                                            2 columns │
└──────────────────────────────────────────────────────────────┘
</code></pre><p>Let&rsquo;s see how we can accomplish the same in the Graph DB counterpart. First, the
schema:</p><pre tabindex=0><code>CREATE NODE TABLE Airport(
    airport_code STRING,
    name STRING,
    city STRING,
    PRIMARY KEY (airport_code)
);

CREATE REL TABLE Route(
    FROM Airport TO Airport,
    flight_no STRING,
    aircraft_code STRING,
    duration INTERVAL,
    days_of_week INT64[]
)
</code></pre><p>Now for the query (shortest route from UKX to CNN based on number of hops from
one airport to the next):</p><pre tabindex=0><code>MATCH p=(a:Airport)-[:Route* ALL SHORTEST]-&gt;(b:Airport)
WHERE a.airport_code = &#39;UKX&#39;
AND b.airport_code = &#39;CNN&#39;
RETURN
    properties(nodes(p), &#39;airport_code&#39;) as hops,
    properties(rels(p), &#39;flight_no&#39;) as flights
</code></pre><p>So far so good. It seems both elegant and succinct, definitely not as hairy as
the SQL variant.</p><p>Also, just to make sure we&rsquo;re getting the same results, we can take advantage of
both Kuzu and DuckDB&rsquo;s arrow export feature plus the <code>except</code> clause in SQL:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>duckdb_conn.register(<span style=font-style:italic>&#34;A&#34;</span>, kuzu_res)
</span></span><span style=display:flex><span>duckdb_conn.register(<span style=font-style:italic>&#34;B&#34;</span>, duckdb_res)
</span></span><span style=display:flex><span>tables_match = duckdb_conn.sql(
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=font-style:italic>select
</span></span></span><span style=display:flex><span><span style=font-style:italic>    (count(*) == 0)
</span></span></span><span style=display:flex><span><span style=font-style:italic>    and
</span></span></span><span style=display:flex><span><span style=font-style:italic>    (select count(*) from A) == (select count(*) from B)
</span></span></span><span style=display:flex><span><span style=font-style:italic>    as tables_match
</span></span></span><span style=display:flex><span><span style=font-style:italic>from (
</span></span></span><span style=display:flex><span><span style=font-style:italic>    select hops,flights from A except all
</span></span></span><span style=display:flex><span><span style=font-style:italic>    select hops,flights from B
</span></span></span><span style=display:flex><span><span style=font-style:italic>)
</span></span></span><span style=display:flex><span><span style=font-style:italic>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>).fetchone()
</span></span><span style=display:flex><span><span style=font-weight:700>assert</span> tables_match[0] == <span style=font-weight:700>True</span>
</span></span></code></pre></div><p>What if we&rsquo;re interested in the route where we&rsquo;ll spend the least amount of time
in air (ignoring the time we&rsquo;ll spend in airports while we wait for the
connection flights). With SQL, we can extend the first query which results in
the following solution:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> starting_point = <span style=font-style:italic>&#39;UKX&#39;</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> destination = <span style=font-style:italic>&#39;CNN&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>with</span> <span style=font-weight:700>recursive</span> p(hops, flights, curr_airport, total_duration, <span style=font-weight:700>found</span>) <span style=font-weight:700>as</span> (
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        [getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>)], <span style=font-style:italic>-- airports we&#39;ve been at, so far the start only
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        []::varchar[], <span style=font-style:italic>-- flights taken, so far none
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>),
</span></span><span style=display:flex><span>        <span style=font-style:italic>&#39;0 minutes&#39;</span>::interval, <span style=font-style:italic>-- we&#39;ve spent 0 minutes flying so far
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>) = <span style=font-weight:700>next</span>.airport_code <span style=font-style:italic>-- reached destination ?
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>from</span> airports <span style=font-weight:700>next</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> <span style=font-weight:700>next</span>.airport_code = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>union</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        list_append(p.hops, r.arrival_airport),
</span></span><span style=display:flex><span>        list_append(p.flights, r.flight_no),
</span></span><span style=display:flex><span>        r.arrival_airport, <span style=font-style:italic>-- curr airport
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        total_duration + r.duration,
</span></span><span style=display:flex><span>        bool_or(r.arrival_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)) over()
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> routes r, p
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> r.departure_airport = p.curr_airport
</span></span><span style=display:flex><span>    <span style=font-weight:700>and</span> <span style=font-weight:700>not</span> r.arrival_airport = <span style=font-weight:700>any</span>(p.hops)
</span></span><span style=display:flex><span>    <span style=font-weight:700>and</span> <span style=font-weight:700>not</span> p.<span style=font-weight:700>found</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> * exclude r <span style=font-weight:700>from</span> (
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        hops, flights, total_duration,
</span></span><span style=display:flex><span>        rank() over(<span style=font-weight:700>order</span> <span style=font-weight:700>by</span> total_duration <span style=font-weight:700>asc</span>) <span style=font-weight:700>as</span> r
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> p
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> p.curr_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>where</span> r = 1
</span></span></code></pre></div><p>This gives us the following results:</p><pre tabindex=0><code>┌───────────────────────────┬──────────────────────────────────┬────────────────┐
│           hops            │             flights              │ total_duration │
│         varchar[]         │            varchar[]             │    interval    │
├───────────────────────────┼──────────────────────────────────┼────────────────┤
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0207, PG0390, PG0036] │ 10:25:00       │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0206, PG0390, PG0036] │ 10:25:00       │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0207, PG0390, PG0035] │ 10:25:00       │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0206, PG0390, PG0035] │ 10:25:00       │
└───────────────────────────┴──────────────────────────────────┴────────────────┘
</code></pre><p>With Kuzu, we&rsquo;ll have to recast the flight durations as integers (minutes) since
it doesn&rsquo;t support summing intervals, yet. The equivalent query I ended up with
is as follows:</p><pre tabindex=0><code>MATCH p=
    (a:Airport {airport_code: &#39;UKX&#39;})-[:Route* ALL SHORTEST]-&gt;(b:Airport {airport_code: &#39;CNN&#39;})
WITH min(list_sum(properties(rels(p), &#39;duration&#39;))) as min_duration
MATCH p=
    (a:Airport {airport_code: &#39;UKX&#39;})-[:Route* ALL SHORTEST]-&gt;(b:Airport {airport_code: &#39;CNN&#39;})
WITH p as p, min_duration as min_duration, list_sum(properties(rels(p), &#39;duration&#39;)) as d 
WHERE d = min_duration
RETURN
    properties(nodes(p), &#39;airport_code&#39;) as hops,
    properties(rels(p), &#39;flight_no&#39;) as flights,
    to_minutes(d) as total_duration
</code></pre><p>There might be some better way of writing it but this is what I was able to come
up with after an evening of studying cypher. The <code>with</code> clause lets us break the
query into steps.</p><p>In the first part, we get the minimum duration amongst all paths from UKX to
CNN:</p><pre tabindex=0><code>MATCH p=
    (a:Airport {airport_code: &#39;UKX&#39;})-[:Route* ALL SHORTEST]-&gt;(b:Airport {airport_code: &#39;CNN&#39;})
WITH min(list_sum(properties(rels(p), &#39;duration&#39;))) as min_duration
</code></pre><p>Then in the second part, we get all the paths that have this exact minimum
duration:</p><pre tabindex=0><code>MATCH p=
    (a:Airport {airport_code: &#39;UKX&#39;})-[:Route* ALL SHORTEST]-&gt;(b:Airport {airport_code: &#39;CNN&#39;})
WITH p as p, min_duration as min_duration, list_sum(properties(rels(p), &#39;duration&#39;)) as d 
WHERE d = min_duration
RETURN
    properties(nodes(p), &#39;airport_code&#39;) as hops,
    properties(rels(p), &#39;flight_no&#39;) as flights,
    to_minutes(d) as total_duration
</code></pre><p>The <code>with</code> clause was a bit hard for me to wrap my head around; in my opinion
CTEs and explicit sub-queries seem more approachable. Kuzu DB&rsquo;s Cypher does have
subqueries but they are rather limited in terms of where they can be placed and
used. Regardless, I was able to get the job done.</p><p>As an aside, given that both Kuzu and DuckDB <em>speak</em> arrow, we could use the
Kuzu to get all the paths, then use DuckDB to pick the shortest path:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>kuzu</span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> <span style=font-weight:700>duckdb</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>db = kuzu.Database(<span style=font-style:italic>&#34;flights&#34;</span>)
</span></span><span style=display:flex><span>kuzu_conn = kuzu.Connection(db)
</span></span><span style=display:flex><span>routes_tbl = kuzu_conn.execute(
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=font-style:italic>MATCH p=
</span></span></span><span style=display:flex><span><span style=font-style:italic>    (a:Airport {airport_code: &#39;UKX&#39;})-[:Route* ALL SHORTEST]-&gt;(b:Airport {airport_code: &#39;CNN&#39;})
</span></span></span><span style=display:flex><span><span style=font-style:italic>RETURN
</span></span></span><span style=display:flex><span><span style=font-style:italic>    properties(nodes(p), &#39;airport_code&#39;) as hops,
</span></span></span><span style=display:flex><span><span style=font-style:italic>    properties(rels(p), &#39;flight_no&#39;) as flights,
</span></span></span><span style=display:flex><span><span style=font-style:italic>    to_minutes(list_sum(properties(rels(p), &#39;duration&#39;))) as total_duration
</span></span></span><span style=display:flex><span><span style=font-style:italic>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>).get_as_arrow()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>duckdb.sql(
</span></span><span style=display:flex><span>    <span style=font-style:italic>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=font-style:italic>select * exclude r from (
</span></span></span><span style=display:flex><span><span style=font-style:italic>    select
</span></span></span><span style=display:flex><span><span style=font-style:italic>        hops,
</span></span></span><span style=display:flex><span><span style=font-style:italic>        flights,
</span></span></span><span style=display:flex><span><span style=font-style:italic>        total_duration,
</span></span></span><span style=display:flex><span><span style=font-style:italic>        rank() over(order by total_duration asc) as r
</span></span></span><span style=display:flex><span><span style=font-style:italic>    from routes_tbl
</span></span></span><span style=display:flex><span><span style=font-style:italic>) where r = 1
</span></span></span><span style=display:flex><span><span style=font-style:italic>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>).show()
</span></span></code></pre></div><p>For the final exercise, a query we might find useful in &lsquo;real-life&rsquo;: given two
airports UKX and CNN and the specific time when we want to commence our journey,
we&rsquo;d like to find the path of flights where we&rsquo;ll spend the least amount of time
including the waits for connection flights. To make it slightly harder (and more
realistic), there&rsquo;s a temporal aspect, we have a specific time when we&rsquo;ll be
starting the journey. Therefore, at each hop, we have to pick the
soonest/closest/earliest flights to avoid spending too much time at the airport.</p><p>Solving it in SQL is a bit more challenging but I was able to get the job done.
Here&rsquo;s my solution:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-style:italic>-- starting point and ending point, set by user
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> starting_point = <span style=font-style:italic>&#39;UKX&#39;</span>;
</span></span><span style=display:flex><span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> destination = <span style=font-style:italic>&#39;CNN&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>-- point in time dataset was generated
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> now = <span style=font-style:italic>&#39;2017-08-15 18:00:00&#39;</span>::<span style=font-weight:700>timestamp</span> <span style=font-weight:700>at</span> time <span style=font-weight:700>zone</span> <span style=font-style:italic>&#39;Europe/Moscow&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>-- time from which onwards we&#39;re ready for departure
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>set</span> <span style=font-weight:700>variable</span> starting_time = getvariable(<span style=font-style:italic>&#39;now&#39;</span>) - <span style=font-style:italic>&#39;20 days&#39;</span>::interval;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>with</span> <span style=font-weight:700>recursive</span>
</span></span><span style=display:flex><span>p(hops, flights, curr_airport, time_user_arrived_at_curr_airport, total_duration, closest, <span style=font-weight:700>found</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>as</span> (
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span> * <span style=font-weight:700>from</span> (
</span></span><span style=display:flex><span>        <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>            [departure_airport, arrival_airport]::varchar[] <span style=font-weight:700>as</span> hops,
</span></span><span style=display:flex><span>            [flight_no]::varchar[] <span style=font-weight:700>as</span> flights,
</span></span><span style=display:flex><span>            arrival_airport <span style=font-weight:700>as</span> curr_airport, <span style=font-style:italic>-- where we are
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            scheduled_arrival <span style=font-weight:700>as</span> time_user_arrived_at_curr_airport,
</span></span><span style=display:flex><span>            (scheduled_arrival - scheduled_departure) <span style=font-weight:700>as</span> total_duration,
</span></span><span style=display:flex><span>            rank() over(
</span></span><span style=display:flex><span>                partition <span style=font-weight:700>by</span> flight_no, departure_airport, arrival_airport
</span></span><span style=display:flex><span>                <span style=font-weight:700>order</span> <span style=font-weight:700>by</span> scheduled_departure <span style=font-weight:700>asc</span>
</span></span><span style=display:flex><span>            ) <span style=font-weight:700>as</span> closest,
</span></span><span style=display:flex><span>            arrival_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>) <span style=font-weight:700>as</span> <span style=font-weight:700>found</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>from</span> flights
</span></span><span style=display:flex><span>        <span style=font-weight:700>where</span>
</span></span><span style=display:flex><span>            departure_airport = getvariable(<span style=font-style:italic>&#39;starting_point&#39;</span>)
</span></span><span style=display:flex><span>            <span style=font-weight:700>and</span> scheduled_departure &gt;= (getvariable(<span style=font-style:italic>&#39;now&#39;</span>) - <span style=font-style:italic>&#39;20 days&#39;</span>::interval)
</span></span><span style=display:flex><span>    ) <span style=font-weight:700>where</span> closest = 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>union</span> <span style=font-weight:700>all</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span> * <span style=font-weight:700>from</span> (
</span></span><span style=display:flex><span>        <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>            list_append(p.hops, f.arrival_airport) <span style=font-weight:700>as</span> hops,
</span></span><span style=display:flex><span>            list_append(p.flights, f.flight_no) <span style=font-weight:700>as</span> flights,
</span></span><span style=display:flex><span>            f.arrival_airport <span style=font-weight:700>as</span> curr_airport,
</span></span><span style=display:flex><span>            f.scheduled_arrival <span style=font-weight:700>as</span> arrived_at_time,
</span></span><span style=display:flex><span>            p.total_duration
</span></span><span style=display:flex><span>                <span style=font-style:italic>-- duration user will spend flying to next airport
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>                + (f.scheduled_arrival - f.scheduled_departure)
</span></span><span style=display:flex><span>                <span style=font-style:italic>-- duration user will wait before departure
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>                + (f.scheduled_departure - p.time_user_arrived_at_curr_airport),
</span></span><span style=display:flex><span>            rank() over(
</span></span><span style=display:flex><span>                partition <span style=font-weight:700>by</span> flight_no, departure_airport, arrival_airport
</span></span><span style=display:flex><span>                <span style=font-weight:700>order</span> <span style=font-weight:700>by</span> scheduled_departure <span style=font-weight:700>asc</span>
</span></span><span style=display:flex><span>            ) <span style=font-weight:700>as</span> closest,
</span></span><span style=display:flex><span>            bool_or(f.arrival_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)) over()
</span></span><span style=display:flex><span>        <span style=font-weight:700>from</span> flights f
</span></span><span style=display:flex><span>        <span style=font-weight:700>inner</span> <span style=font-weight:700>join</span> p <span style=font-weight:700>on</span> f.departure_airport = p.curr_airport
</span></span><span style=display:flex><span>        <span style=font-weight:700>where</span>
</span></span><span style=display:flex><span>            f.scheduled_departure &gt;= p.time_user_arrived_at_curr_airport
</span></span><span style=display:flex><span>            <span style=font-weight:700>and</span> <span style=font-weight:700>not</span> f.arrival_airport = <span style=font-weight:700>any</span>(p.hops) <span style=font-style:italic>-- no cycles
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-weight:700>and</span> <span style=font-weight:700>not</span> p.<span style=font-weight:700>found</span> <span style=font-style:italic>-- have we arrived at destiation yet?
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    ) <span style=font-weight:700>where</span> closest = 1
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>select</span> * exclude r <span style=font-weight:700>from</span> (
</span></span><span style=display:flex><span>    <span style=font-weight:700>select</span>
</span></span><span style=display:flex><span>        hops, flights, total_duration,
</span></span><span style=display:flex><span>        rank() over(<span style=font-weight:700>order</span> <span style=font-weight:700>by</span> total_duration <span style=font-weight:700>asc</span>) <span style=font-weight:700>as</span> r
</span></span><span style=display:flex><span>    <span style=font-weight:700>from</span> p
</span></span><span style=display:flex><span>    <span style=font-weight:700>where</span> p.curr_airport = getvariable(<span style=font-style:italic>&#39;destination&#39;</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=font-weight:700>where</span> r = 1
</span></span><span style=display:flex><span><span style=font-weight:700>order</span> <span style=font-weight:700>by</span> flights
</span></span></code></pre></div><p>It gives us the following routes:</p><pre tabindex=0><code>┌───────────────────────────┬──────────────────────────────────┬────────────────┐
│           hops            │             flights              │ total_duration │
│         varchar[]         │            varchar[]             │    interval    │
├───────────────────────────┼──────────────────────────────────┼────────────────┤
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0206, PG0390, PG0035] │ 70:55:00       │
│ [UKX, KJA, OVB, MJZ, CNN] │ [PG0022, PG0207, PG0390, PG0035] │ 70:55:00       │
│ [UKX, KJA, SVO, MJZ, CNN] │ [PG0022, PG0548, PG0120, PG0035] │ 70:55:00       │
└───────────────────────────┴──────────────────────────────────┴────────────────┘
</code></pre><p>Now with Cypher, I would have to add a new kind of edge for individual flights
rather than general route:</p><pre tabindex=0><code>CREATE REL TABLE Flight(
    FROM Airport TO Airport,
    flight_id INT64,
    flight_no STRING,
    aircraft_code STRING,
    scheduled_departure TIMESTAMP,
    scheduled_arrival TIMESTAMP,
    status STRING,
    actual_departure TIMESTAMP,
    actual_arrival TIMESTAMP
)
</code></pre><p>However, I was unable to formulate a solution in Cypher. If you can do it,
please reach out, I&rsquo;d love to learn how.</p><p>Overall, Cypher seems neat. For simple graph queries, it offers a better
interface than SQL. For more complex queries, SQL has a wider array of tools
that one can use when tackling them. I&rsquo;ll be spending as much time as possible
with Graph DBs so I can understand better what they&rsquo;re great at and what I can
accomplish with them. Cheers.</p></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/blog/vss-duckdb-caveats/>Some Notes on Vector Indexing in DuckDB</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/blog/pg-parquet-archive-timeseries/>Archiving Time-Series Data from PostgreSQL into Parquet</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>&mldr;</p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>