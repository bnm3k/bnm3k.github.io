<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="https://bnm3k.github.io//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://bnm3k.github.io//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://bnm3k.github.io//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://bnm3k.github.io//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://bnm3k.github.io//apple-touch-icon.png">

<meta name="description" content=""/>

<title>
    
    Golang Custom Loggers: using Postgres and Leveldb | bnm 3000
    
</title>

<link rel="canonical" href="https://bnm3k.github.io/blog/go-custom-logger-pg-leveldb/"/>

<meta property="og:url" content="https://bnm3k.github.io/blog/go-custom-logger-pg-leveldb/">
  <meta property="og:site_name" content="bnm 3000">
  <meta property="og:title" content="Golang Custom Loggers: using Postgres and Leveldb">
  <meta property="og:description" content="Coupling logging to the some destination (in this case Postgres and leveldb) within the application itself isn’t by any means a good idea. Still, given the flexibility interfaces in Go provide, why not give it a try ¯\(ツ)/¯">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2019-12-20T00:00:00+00:00">
    <meta property="article:modified_time" content="2019-12-20T00:00:00+00:00">
    <meta property="article:tag" content="Golang">













<link rel="stylesheet" href="/assets/combined.min.186794b3399a702d3092949042cdc215dea303c17e71e7c0254768448de11db8.css" media="all">









  </head>

  

  
  
  

  <body class="light">

    <div class="content">
      <header>
        

<div class="header">

    

    <h1 class="header-title">
        <a href="https://bnm3k.github.io/">bnm 3000</a>
    </h1>

    <div class="flex">
        

        
        
      
        <p class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/notes" >
                /notes
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/tags" >
                /tags
            </a>
        </p>
        
        
    </div>

    

</div>

      </header>

      <main class="main">
        





<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/notes/">Notes</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/blog/go-custom-logger-pg-leveldb/">Golang Custom Loggers: using Postgres and Leveldb</a>
</div>



<div >

  <div class="single-intro-container">

    

    <h1 class="single-title">Golang Custom Loggers: using Postgres and Leveldb</h1>
    
    <p class="single-summary">Coupling logging to the some destination (in this case Postgres and leveldb) within the application itself isn&rsquo;t by any means a good idea. Still, given the flexibility interfaces in Go provide, why not give it a try ¯\<em>(ツ)</em>/¯</p>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2019-12-20T00:00:00&#43;00:00">December 20, 2019</time>
      

      
      &nbsp; · &nbsp;
      19 min read
      
    </p>

  </div>

  

  

  

  

  <div class="single-content">
    <p>Golang&rsquo;s standard library provides the handy <a href="https://golang.org/pkg/log/">log</a>
package which suffices for most simple logging cases. Usually, the logs are
output to the standard streams (stdout or stderr). From there, they can be
redirected as needed. Alternatively, the log outputs can also be written
directly to a file.</p>
<p>Still, I was curious as to what it would take to use a relational database (like
Postgres) as a destination for the log outputs while sticking to the <strong>log</strong>
API. Therefore when reading this post, please do take it as more of
exploratory/casual rather than didactic or some sort of sagely best-practices.</p>
<h3 class="heading" id="overview-of-the-log-package">
  Overview of the log Package
  <a href="#overview-of-the-log-package">#</a>
</h3>
<p>The log package gives us two options: we can either create our own logger
manually, or we can use its default standard logger. We&rsquo;ll opt to create our own
logger assuming that different parts of the program will require their own
specialized/leveled logger (e.g. for logging errors only or for logging
informational messages only). Furthermore, everything we do with a customized
logger can be extended to work with the default logger provided.</p>
<h3 class="heading" id="creating-a-logger">
  Creating a logger
  <a href="#creating-a-logger">#</a>
</h3>
<p>Using <a href="https://golang.org/src/log/log.go?s=2897:2953#L52">log.New</a>, we can
create our own custom loggers. <em>log.New</em> has the following signature:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> New(out io.Writer, prefix <span style="">string</span>, flag <span style="">int</span>) *Logger
</span></span></code></pre></div><p>Let&rsquo;s start with the <em>out</em> parameter. The key thing to note, is that the
argument doesn&rsquo;t necessarily have to be a file or one of the standard streams
such as <em>os.Stdout</em>- all it has to be, or rather do, is implement the
<em>io.Writer</em> interface. Here is the <em>io.Writer</em> interface:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">type</span> Writer <span style="font-weight:bold">interface</span> {
</span></span><span style="display:flex;"><span>    Write(p []<span style="">byte</span>) (n <span style="">int</span>, err <span style="">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This does give us a lot of freedom. For my use case, I&rsquo;m implementing an
interface that sort of &lsquo;redirects&rsquo; all log outputs to postgres.</p>
<p>The next parameter in the <em>log.New</em> function is the <em>prefix</em> parameter. This
gives us a basic way to create leveled logging, that is, different loggers can
use different prefixes to set themselves apart.</p>
<p>Finally, we have the <em>flag</em> parameter which adds additional prefixes to the log
output. These additional prefixes can contain the date and/or the time the log
was created plus (if required) the associated filename and/or filepath from
which the log was generated. In order to set the <em>flag</em> correctly, we have to
use the constants that the package provides us.</p>
<h3 class="heading" id="parsing-and-structuring-the-log-output-preliminaries">
  Parsing and structuring the log output (preliminaries)
  <a href="#parsing-and-structuring-the-log-output-preliminaries">#</a>
</h3>
<p>With all the flags that give maximum information in the prefix set (Ldate |
Ltime | Lmicroseconds | Llongfile), plus adding the prefix &lsquo;ERROR&rsquo;, the log
ouput has the following format:</p>
<pre tabindex="0"><code>ERROR 2009/01/23 01:23:23.123123 /a/b/c/d.go:23: some error message
</code></pre><p>This could be dumped as is directly to postgres using the &rsquo;text&rsquo; data type for
storage. However, since I&rsquo;m going through all these hassle to use Postgres, I
might as well take full advantage of it and enforce a structure for the log
output.</p>
<p>In order to do so, the first step is parsing the log string. This looks like a
job for the almighty regex.</p>
<p>We can already see the fields that we want to extract, such as the date, the
prefix, the associated file, and most importantly, the actual log message.</p>
<p>I&rsquo;m more comfortable using javascript for regex stuff so that&rsquo;s where I tinkered
for a while before settling on the pattern to use. Note that, since a user can
set their own flags, (e.g. getting rid of the filepath when logging http
requests since its irrelevant), this has to be taken into account by making the
related patterns optional:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="font-weight:bold">const</span> parseLog = (() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">const</span> r =
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">/^(\w+)\s+(\d{4}\/\d{2}\/\d{2}\s)?(\d{2}:\d{2}:\d{2}(\.\d+)?\s)?(.*\.go:\d+:\s)?([^]*)/</span>;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> (logStr) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">let</span> match = r.exec(logStr);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> match
</span></span><span style="display:flex;"><span>      ? {
</span></span><span style="display:flex;"><span>        prefix: match[1],
</span></span><span style="display:flex;"><span>        date: match[2] &amp;&amp; match[2].trim(),
</span></span><span style="display:flex;"><span>        time: match[3] &amp;&amp; match[3].trim(),
</span></span><span style="display:flex;"><span>        file: match[5] &amp;&amp; match[5].trim(),
</span></span><span style="display:flex;"><span>        payload: match[6],
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      : <span style="font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>})();
</span></span></code></pre></div><p><em>parseLog</em> closes over the &lsquo;r&rsquo; pattern since I didn&rsquo;t want the pattern to be
recompiled every time the function is called - though this might very much be
unnecessary, I probably should check the relevant MDN docs on this later on.</p>
<p>The regex can be broken down as follows:</p>
<ol>
<li>
<p><strong>/^</strong>: the beginning, standard stuff</p>
</li>
<li>
<p><strong>(\w+)\s+</strong>: matches the prefix which is expected to be alphanumeric
characters only plus a bit of space. When we go back to Golang, we must find
a way to enforce this, for example, when creating the logger</p>
</li>
<li>
<p><strong>(\d{4}/\d{2}/\d{2}\s)?</strong>: this matches the date portion of the log output
plus a bit of space. However, the date can be omitted therefore the match is
made optional.</p>
</li>
<li>
<p><strong>(\d{2}:\d{2}:\d{2}(.\d+)?\s)?</strong>: matches the time portion, the microseconds
may or may not be provided. As with the date, we must also take into account
that the time can be ommitted</p>
</li>
<li>
<p><strong>(.*.go:\d+:\s)?</strong>: matches the file part. From golang&rsquo;s documentation of
the log output, we know that regardless of whether the full path or just the
file name is provided, a colon is appended at the end. I&rsquo;m also assuming that
all files have the &lsquo;.go&rsquo; extension. This is a &lsquo;known unknown&rsquo;. There are
probably some
&lsquo;<a href="https://en.wikipedia.org/wiki/There_are_known_knowns">unknown unknown</a>&rsquo;
assumptions that I&rsquo;m making in this regex pattern that might result in errors
later on, but for now, these assumptions remain in the realm of the unknown
unknowns.</p>
</li>
<li>
<p><strong>([^]*)</strong>: Finally, this match is used to capture the actual payload of the
log output. It&rsquo;s supposed to match every character including a newline
character.</p>
</li>
</ol>
<p>Using <em>parseLog</em> with the sample log output provided earlier, we get:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    prefix: <span style="font-style:italic">&#39;ERROR&#39;</span>,
</span></span><span style="display:flex;"><span>    date: <span style="font-style:italic">&#39;2009/01/23&#39;</span>,
</span></span><span style="display:flex;"><span>    time: <span style="font-style:italic">&#39;01:23:23.123123&#39;</span>,
</span></span><span style="display:flex;"><span>    file: <span style="font-style:italic">&#39;/a/b/c/d.go:23:&#39;</span>,
</span></span><span style="display:flex;"><span>    payload: <span style="font-style:italic">&#39;some error message&#39;</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Satisfied with the javascript <em>parseLog</em> as it is for now, the next step was to
translate it to Go. This was a bit tricky for me since up to that point, I&rsquo;d
never used regular expressions in Go so I had to spend some time working through
Go&rsquo;s regex package.</p>
<h3 class="heading" id="parsing-and-structuring-the-log-outputs-golang-implementation">
  Parsing and structuring the log outputs (Golang implementation)
  <a href="#parsing-and-structuring-the-log-outputs-golang-implementation">#</a>
</h3>
<p>I usually find myself front-loading a lot of the key design decisions when using
Go, which is great to some extent (most of the times) since I&rsquo;m still going to
have to think about and formalize such matters at some point either way. But
sometimes it leads to premature over-abstraction. In javascript though, I often
find myself freestyling until I arrive at what I want; it&rsquo;s only by forcing
myself lately to use TDD that I&rsquo;ve started front-loading design decisions in js
too.</p>
<p>Back to logging: I&rsquo;ve opted to sort of encapsulate the regex pattern into a
struct with its own type to allow for coupling associated methods (such as
<em>parseLog</em>) and also allow for different regexes to be used depending on the
logger: again a hunch tells me this might be over-abstraction&hellip;</p>
<p>We&rsquo;ll have a type &rsquo;logParser&rsquo; which will encapsulate the regex pattern as so:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">type</span> logParser <span style="font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    logRegexMatch *regexp.Regexp
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Therefore, we&rsquo;ll have to supply some means for initialzing <em>logParser</em> with the
default regex pattern. I used the back-ticks since when using the usual double
quotes for strings, I have to escape all the backslashes in the regex pattern
which is cumbersome and adds unnecessary noise. I&rsquo;ve also used <em>MustCompile</em>
since it&rsquo;s more terse and I am not dealing with a dynamic pattern. Lastly, in
order to capture the payload, I&rsquo;ve changed the pattern from <code>([^]*)</code> to
<code>([\w\W]\*)</code> since the former throws an error in Go for some reason:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> newLogParser() *logParser {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> &amp;logParser{
</span></span><span style="display:flex;"><span>        logRegexMatch: regexp.MustCompile(<span style="font-style:italic">`^(\w+)\s+(\d{4}\/\d{2}\/\d{2}\s)?(\d{2}:\d{2}:\d{2}(\.\d+)?\s)?(.*\.go:\d+:\s)?([\w\W]*)`</span>),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Separately, there&rsquo;s also a type that captures parsed logs:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">type</span> parsedLog <span style="font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    Prefix  <span style="">string</span>
</span></span><span style="display:flex;"><span>    LogTime time.Time
</span></span><span style="display:flex;"><span>    File    <span style="">string</span>
</span></span><span style="display:flex;"><span>    Payload <span style="">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Back to <em>logParser</em>, the following method for parsing the logs is added:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> (lp *logParser) parseLog(str <span style="">string</span>) (*parsedLog, <span style="">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">var</span> err <span style="">error</span> = <span style="font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">var</span> pl *parsedLog
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    matches := lp.logRegexMatch.FindStringSubmatch(str)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> matches != <span style="font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">var</span> logTime time.Time
</span></span><span style="display:flex;"><span>        logTime, err = parseLogTime(matches[2], matches[3])
</span></span><span style="display:flex;"><span>        pl = &amp;parsedLog{
</span></span><span style="display:flex;"><span>            Prefix:  matches[1],
</span></span><span style="display:flex;"><span>            LogTime: logTime,
</span></span><span style="display:flex;"><span>            File:    strings.TrimSpace(matches[5]),
</span></span><span style="display:flex;"><span>            Payload: matches[6],
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        err = ErrInvalidLog
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">nil</span>, ErrInvalidLog
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> pl, <span style="font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since I opted to store the date and time into a <em>time.Time</em> variable rather than
a string variable, I have to convert them. Hence the <em>parseLogTime</em> function. It
gives us a bit of flexibility but postgres is already great at parsing date and
time strings into timestamp so this might be unnecessary work on the
application&rsquo;s part.</p>
<p>Without further ado, here&rsquo;s the <em>parseLogTime</em> function. Note that the extra
space that logger adds after the date and time values has to be accounted for;
in javascript land, I used <em>trim</em> to get rid of such space characters.
Alternatively, I could have used extra groups to match out just the date and
time portions without space in the regex but I opted for otherwise since it made
the regex much harder to inspect by eye.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> parseLogTime(dateVal, timeVal <span style="">string</span>) (time.Time, <span style="">error</span>) {
</span></span><span style="display:flex;"><span>    now := time.Now()
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">var</span> t time.Time
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">var</span> err <span style="">error</span> = <span style="font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> dateVal == <span style="font-style:italic">&#34;&#34;</span> &amp;&amp; timeVal == <span style="font-style:italic">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// No date val. No time val
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        <span style="font-weight:bold">return</span> now, <span style="font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> <span style="font-weight:bold">if</span> dateVal == <span style="font-style:italic">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// Only time val provided&#34;
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        y, m, d := now.Date()
</span></span><span style="display:flex;"><span>        dtValStr := fmt.Sprintf(<span style="font-style:italic">&#34;%v/%02d/%02d %s&#34;</span>, y, m, d, timeVal)
</span></span><span style="display:flex;"><span>        t, err = time.Parse(<span style="font-style:italic">&#34;2006/01/02 15:04:05.999999 &#34;</span>, dtValStr)
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> <span style="font-weight:bold">if</span> timeVal == <span style="font-style:italic">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// Only date val provided&#34;
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        t, err = time.Parse(<span style="font-style:italic">&#34;2006/01/02 &#34;</span>, dateVal)
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="font-style:italic">// Both date val and time val provided
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>        dtValStr := fmt.Sprintf(<span style="font-style:italic">&#34;%s%s&#34;</span>, dateVal, timeVal)
</span></span><span style="display:flex;"><span>        t, err = time.Parse(<span style="font-style:italic">&#34;2006/01/02 15:04:05.999999 &#34;</span>, dtValStr)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> t, err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Back in <em>logParser</em>, there&rsquo;s also the ErrInvalidLog error just in case something
goes wrong and feedback is required:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-style:italic">//ErrInvalidLog ..
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span><span style="font-weight:bold">var</span> ErrInvalidLog = errors.New(<span style="font-style:italic">&#34;Invalid Log. Unable to Parse&#34;</span>)
</span></span></code></pre></div><p>So far, all the types and methods have been private since, if this is to be
repackaged into a reusable package, the user shouldn&rsquo;t have to care about the
how the log is parsed, all they&rsquo;d require is a logger equivalent to what Go&rsquo;s
standard library provides.</p>
<h3 class="heading" id="setting-up-postgres">
  Setting up Postgres
  <a href="#setting-up-postgres">#</a>
</h3>
<p>Before going any further, since the ultimate goal is to store the logs in
Postgres, it&rsquo;s best to think about how the tables should be designed.</p>
<p>Courtesy of how <em>parseLogTime</em> is structured, there will always be a <em>LogTime</em>
regardless of whether the user adds the date/time flags- the rest of the values
though might be omitted. With that in mind, the log table probably needs a
primary key. At first, I thought of using the <em>LogTime</em> value as the primary key
for each entry, since I&rsquo;ll also get indexing for free which will come in handy
when querying the logs. However, even if it&rsquo;s highly improbable, it&rsquo;s still
quite possible that two different logs might end up having the same log time and
one of them will have to be discarded (due to the uniqueness constraint for
primary keys). Another alternative is to use a synthetic key (e.g. an
incrementing integer) in combination, or even in leau of the timestamp. But, I
opted to forgo having a primary key altogether until such a need arose - e.g. if
I need to use some column in the table as a foreign key.</p>
<p>Another aspect that needs to be considered is which type to use for the
<em>LogTime</em> value. Postgres provides two types for timestamps, &rsquo;timestamp&rsquo; and
&rsquo;timestamptz&rsquo;. With &rsquo;timestamp&rsquo;, it simply takes the log time as it is and store
it. While choosing one or the other, I have to take into consideration the fact
that our application and the postgres server might be running in two different
timezones, or even simply that postgres is configured to a different timezone.
For the time being, I went with timestamp, and just as with the primary key,
I&rsquo;ll consider timestamptz when the need arises.</p>
<p>All in all, the table definition ends up being as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="font-weight:bold">create</span> <span style="font-weight:bold">table</span> log(
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">prefix</span> varchar(15),
</span></span><span style="display:flex;"><span>    log_time <span style="font-weight:bold">timestamp</span>,
</span></span><span style="display:flex;"><span>    file text,
</span></span><span style="display:flex;"><span>    payload text
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>With logs, the two common kinds of queries over the table we can expect are
range queries on the <em>log_time</em> column and full-text search over the text, or
even simple text search. As such, I should probably add the necessary indices
but I&rsquo;ll postpone it for now.</p>
<h3 class="heading" id="writing-logs-to-postgres">
  Writing logs to postgres
  <a href="#writing-logs-to-postgres">#</a>
</h3>
<p>Back in the Go application, the logger and postgres need to be &lsquo;glued&rsquo; together.</p>
<p>I&rsquo;ll offload the labor of setting up a connection to Postgres to the logger user
rather than setting it up within the logger constructor. This adds a lot of
flexibility. It also allows the same *<em>sql.DB</em> instance to be reused across the
application.</p>
<p>The <em>customOutPG</em> struct type will be used to encapsulate the postgres db
instance. As the name suggests, <em>customOutPG</em> will implement the <em>io.Writer</em>
interface so that it can subsequently be used within a <em>logger</em> instance.
<em>customOut</em> also encapsulates a <em>logParser</em> instance for parsing logs before
insertion into postgres.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">type</span> customOutPG <span style="font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    db         *sql.DB
</span></span><span style="display:flex;"><span>    insertStmt <span style="">string</span>
</span></span><span style="display:flex;"><span>    lp         *logParser
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The following function is then used to create instances of the logger:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-style:italic">//NewCustomLoggerPG ...
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span><span style="font-weight:bold">func</span> NewCustomLoggerPG(prefix <span style="">string</span>, flag <span style="">int</span>, db *sql.DB) (*log.Logger, <span style="">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">//ensure prefix is of solely alphanumeric characters
</span></span></span><span style="display:flex;"><span><span style="font-style:italic"></span>    match, err := regexp.MatchString(<span style="font-style:italic">&#34;^\\w+$&#34;</span>, prefix)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> || match == <span style="font-weight:bold">false</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> <span style="font-weight:bold">nil</span>, ErrInvalidPrefix
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cOut := newcustomOutPG(db)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> log.New(cOut, prefix+<span style="font-style:italic">&#34;\t&#34;</span>, flag), <span style="font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">func</span> newcustomOutPG(db *sql.DB) *customOutPG {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> &amp;customOutPG{
</span></span><span style="display:flex;"><span>        db:         db,
</span></span><span style="display:flex;"><span>        insertStmt: <span style="font-style:italic">&#34;insert into log(prefix, log_time, file, payload) values ($1, $2, $3, $4)&#34;</span>,
</span></span><span style="display:flex;"><span>        lp:         newLogParser(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The prefix is constrained to alphanumeric characters only (no spaces, tabs or
special characters and symbols). This is because the regex in <em>parseLog</em> already
assumes so and if this check were to be left out, it would result in certain
errors and malformed outputs depending on the prefix.</p>
<p>An additional ErrInvalidPrefix is included to make it clear to the caller of the
function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">var</span> ErrInvalidPrefix = errors.New(<span style="font-style:italic">&#34;Invalid Prefix&#34;</span>)
</span></span></code></pre></div><p>Finally, the pièce de résistance, the last piece of the puzzle: implementing the
io.Writer interface in <em>customOutPG</em>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> (c *customOutPG) Write(log []<span style="">byte</span>) (<span style="">int</span>, <span style="">error</span>) {
</span></span><span style="display:flex;"><span>    pl, err := c.lp.parseLog(string(log))
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> -1, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _, err = c.db.Exec(c.insertStmt, pl.Prefix, pl.LogTime, pl.File, pl.Payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> len(log), err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Voila! <em>cOut</em> can now be passed directly to <em>log.New</em> with confidence. Keep in
mind though, <em>c.db.Exec</em> is ran, I probably do need to do something more
intelligent when an error is returned, but for now, that budden rests with the
module user.</p>
<h3 class="heading" id="querying-logs">
  Querying logs
  <a href="#querying-logs">#</a>
</h3>
<p>The whole point of storing the logs in Postgres should be the query flexibility
and endless options we get out of the box. <em>listen/notify</em> plus triggers and
other &lsquo;stuff&rsquo; could be used to set up a poor man&rsquo;s monitoring system e.g. if an
&lsquo;fatal&rsquo;-prefixed log is made. As mentioned earlier, full text indexing could be
added on the payload, bring us into
<a href="https://www.elastic.co/products/log-monitoring">Elasticsearch</a> territory. But,
for now, I&rsquo;ll settle for simply querying all the log outputs that occured in the
last 24 hours:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="font-weight:bold">select</span> <span style="font-weight:bold">prefix</span>, log_time, file, payload 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> log 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">where</span> log_time &gt;= now() - <span style="font-style:italic">&#39;1 day&#39;</span>::interval
</span></span></code></pre></div><p>Declaring and using intervals in postgres sql is so expressive that it&rsquo;s quite
easy to modify the above query to instead retrieve the logs from the past 1
week:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="font-weight:bold">select</span> <span style="font-weight:bold">prefix</span>, log_time, file, payload 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> log 
</span></span><span style="display:flex;"><span><span style="font-weight:bold">where</span> log_time &gt;= now() - <span style="font-style:italic">&#39;1 week&#39;</span>::interval
</span></span></code></pre></div><p>Another advantage of using intervals rather than handrolling our own
calculations is that, under the hood, postgres takes care of a lot of edge cases
that come with dealing with date/time data whenever we use intervals.</p>
<p>The prefix can also be used to retrieve only certain kinds of log messages, eg
Errors:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="font-weight:bold">select</span> <span style="font-weight:bold">prefix</span>, log_time, file, payload
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> log
</span></span><span style="display:flex;"><span><span style="font-weight:bold">where</span> log_time &gt;= now() - <span style="font-style:italic">&#39;1 Week&#39;</span>::interval <span style="font-weight:bold">and</span> <span style="font-weight:bold">prefix</span> = <span style="font-style:italic">&#39;ERROR&#39;</span>
</span></span></code></pre></div><p>The querying options are endless and if we need to incorporate some additional
dimension of our logs, such as the process number, we simply add a new column to
our table and use it in our queries.</p>
<h3 class="heading" id="increasing-write-throughput">
  Increasing write throughput
  <a href="#increasing-write-throughput">#</a>
</h3>
<p>This is where things start getting a little bit funky. And by funky, I mean take
the methodologies fleshed out here with a grain of salt.</p>
<p>As it stands, any part of our application that uses the custom Logger has to
wait for postgres to confirm the insertion. Under high load, this ropes in
additional latency (particularly compared to simply logging to stdout or even to
a file).</p>
<p>Now, so far, I&rsquo;ve insisted on delaying optimizations and extensions (such as
adding an index to the log_time column) until they are severely needed. This
section thought sort of betrays any pragmatism I&rsquo;ve claimed to hold. Still, I
thought it might be a fun undertaking just for the sake of it.</p>
<p>The overall goal was to have workers that do the actual logging to the database,
an unbounded concurrent queue and a flush operation which the application can
call to ensure all pending logs have been inserted. Now, for the unbounded
queue, it has its advantages, particularly high-througput but it also has it&rsquo;s
disadvantages in that slow consumers will lead to huge (undesirable) build-up. I
also wanted to avoid using mutex or external modules for this so my only option
for a concurrent queue with the features I required was to use Go&rsquo;s channels.</p>
<p>Without further ado, here&rsquo;s the code. <em>newOutWrapperConc</em> (I should get better
at naming stuff), can wrap any io.Writer. The size of the &lsquo;queue&rsquo;, ie the buffer
size of the channel and the number of workers are set using the &lsquo;bufSize&rsquo; and
&rsquo;logWorkers&rsquo; parameters respectively.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> newOutWrapperConc(out io.Writer, bufSize, logWorkers <span style="">int</span>) *customOutConc {
</span></span><span style="display:flex;"><span>    logsCh := make(<span style="font-weight:bold">chan</span> []<span style="">byte</span>, bufSize)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">var</span> wg sync.WaitGroup
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> i := 0; i &lt; logWorkers; i++ {
</span></span><span style="display:flex;"><span>        wg.Add(1)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">go</span> logWorker(out, logsCh, &amp;wg)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> &amp;customOutConc{
</span></span><span style="display:flex;"><span>        logsCh: logsCh,
</span></span><span style="display:flex;"><span>        wg:     &amp;wg,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As mentioned, there needs to be a &lsquo;flush&rsquo; function. Before so, here&rsquo;s the
customOutConc which encapsulates the <em>logsCh</em> and <em>wg</em> sync.WaitGroup value
which as we shall see, is used to ensure each worker is done before closing.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">type</span> customOutConc <span style="font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    logsCh <span style="font-weight:bold">chan</span> []<span style="">byte</span>
</span></span><span style="display:flex;"><span>    wg     *sync.WaitGroup
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The workers are very simply, they receive logs from the logsCh and write it to
the given io.Writer. When the channel is closed, they indicate via the wg
sync.WaitGroup that they are done:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> logWorker(out io.Writer, logsCh &lt;-<span style="font-weight:bold">chan</span> []<span style="">byte</span>, wg *sync.WaitGroup) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">defer</span> wg.Done()
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> log := <span style="font-weight:bold">range</span> logsCh {
</span></span><span style="display:flex;"><span>        out.Write(log)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>On the other hand, the flush/close function is closed to ensure that no more
logging takes place (lest a panic occurs) and that workers complete any pending
loggings. The flush/close function does this (ensuring all workers are done) by
&lsquo;waiting&rsquo; on the WaitGroup:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> (cc *customOutConc) Close() {
</span></span><span style="display:flex;"><span>    close(cc.logsCh)
</span></span><span style="display:flex;"><span>    cc.wg.Wait()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, the &lsquo;Write&rsquo; method is implemented so that the value itself can be
supplied to a logger instance. When a log is written, it&rsquo;s simply sent to the
<em>logsCh</em> channel so that any of the workers can write it:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">func</span> (cc *customOutConc) Write(log []<span style="">byte</span>) (<span style="">int</span>, <span style="">error</span>) {
</span></span><span style="display:flex;"><span>    cc.logsCh &lt;- log
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> 0, <span style="font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I did some benchmarks (using go test benchmark utility). They were not very
rigorous. The concurrent logger was set to a buffered channel of size 50 and 4r
log workers. When only one goroutine was generating logs, the concurrent logger
was roughly 42% faster than the plain logger. When 10 goroutines were generating
logs concurrently, the concurrent logger was 54% faster than the plain logger.
There are rooms for improvement, for example chunking and inserting multiple
logs in a single sql insert statement. But as it is, it&rsquo;s really not worth the
hussle any further.</p>
<p>On reviewing, this section, with all its messiness, I&rsquo;m more convinced that the
logging within the application should be decoupled entirely from the
destination. Again, to reiterate, there are way better throughput optimizations
and my approach above leaves a lot to be desired.</p>
<h3 class="heading" id="using-an-embedded-database-instead-leveldb">
  Using an embedded database instead (leveldb)
  <a href="#using-an-embedded-database-instead-leveldb">#</a>
</h3>
<p>For simple applications though, using Postgres for logging is a bit excessive.
Even if both the application and Postgres are running on the same machine,
Postgres still has to run as an entire server on a different process. Moreoever,
if the Postgres instance fails or is shut down, or even the connection is messed
up, the application, (with the logging code above so far), also fails along. A
failover strategy such as redirecting to stdout or a file (or even a csv which
will be easier to bulk insert into postgres later on) could be added. Or, an
arguably better alternative, simply use an embedded database which runs in the
same process as the application.</p>
<p>Let&rsquo;s use an embedded database. Since we&rsquo;re already using a relational database,
the option that would require the least amount of modification is
<a href="https://www.sqlite.org/index.html">sqlite</a>. Still, I wanted to try out
something more fun, maybe to the tune of
<a href="https://en.wikipedia.org/wiki/LevelDB">leveldb</a>.</p>
<p>Like sqlite, <a href="https://github.com/syndtr/goleveldb">leveldb</a> is &rsquo;embeddable&rsquo;.
Unlike sqlite, leveldb is a key-value nosql database. Therefore, we don&rsquo;t really
need to parse and structure our log output, we could just dump it as it is into
leveldb. However, we do need to think about which key to use. Such a key not
only has to be unique, it also has to facilitate efficient querying of the log
output. I decided to use a concatenation of both the log prefix and the
timestamp as the key. Additionally, since the log output is already being parsed
into a struct when working with Postgres, it might as well be stored as json:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold">type</span> customOutLevelDB <span style="font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    db *leveldb.DB
</span></span><span style="display:flex;"><span>    lp *logParser
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">func</span> (c *customOutLevelDB) Write(log []<span style="">byte</span>) (<span style="">int</span>, <span style="">error</span>) {
</span></span><span style="display:flex;"><span>    pl, err := c.lp.parseLog(string(log))
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> -1, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    key := fmt.Sprintf(<span style="font-style:italic">&#34;%s!%020d&#34;</span>, pl.Prefix, pl.LogTime.Unix())
</span></span><span style="display:flex;"><span>    plJSON, err := json.Marshal(pl)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> -1, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    err = c.db.Put([]byte(key), plJSON, <span style="font-weight:bold">nil</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> len(log), err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I could (and should) also append a random value such as a
<a href="https://github.com/teris-io/shortid">short-id</a> since two separte logs could
potentially have the same prefix and timestamp but that&rsquo;s let&rsquo;s pretend that&rsquo;ll
never happen.</p>
<p>Note, that the timestamp value is padded. The great thing about relational
databases is that they give us a lot of flexibility and options when it comes to
querying as we have seen. Furthermore, their rich array of data types allow us
to encode more aspects of our data. With key-value stores though, all we have to
work with are keys, for which leveldb only sees as opaque byte arrays,
regardless of what they encode. Since leveldb uses lexicographical order to sort
the keys, we have to keep in mind some of the assumptions inherent in the key
format used above. For one, it&rsquo;s expected that querying will be limited to a
select prefix. Secondly, given that lexicographic order is not the same as
temporal or even numeric order, we might (and will) have situation where an
earlier timestamp is &lsquo;greater&rsquo; than a more recent timestamp when we do know that
the opposite is true. For example, under lexicographic order, the following
relation between the timestamps holds true:</p>
<pre tabindex="0"><code>&#34;15&#34; &gt; &#34;1479953943&#34;
</code></pre><p>This is remedied by padding the timestamp. The prefixes should probably be
padded too but I&rsquo;ve yet to come up with an edge case that necessitates this.
Compared to Sqlite, Leveldb is a fun but poor choice. As mentioned, key-value
stores offer way less query flexibility compared to relational databases (via
sql). Therefore, to regain some of that flexibility lost by moving from Postgres
to Leveldb, a lot of application code has to be written. Furthermore, with the
limited filtering options provided by key-value stores, the application probably
has to read more data than is required.</p>
<p>And that&rsquo;s it! PS, all the code is
<a href="https://github.com/nagamocha3000/db-logger-golang">here</a>. I&rsquo;ve also included a
simple CLI that uses the custom logger, e.g. retrieving logs from db, clearing
logs etc.</p>

    
  </div>

  


  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/blog/sql-bank-txs-v2/">
                        Handling Bank Transactions, V2
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/blog/go-channels-concurrency-sync/">
                        Go Channels Suffice for Synchronization
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      

    
    
    
    <p>&hellip;</p>
    


    </footer>

    

  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>